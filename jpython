#!/usr/bin/python
# some stuff taken from http://eseth.org/filez/prefs/pythonrc.py

import os, sys, time, atexit, pprint, inspect, pydoc
import fcntl, termios, struct
try:
    import pygments
    pygmentsexists = True
except ImportError:
    pygmentsexists = False
    pass

if sys.version_info[0] > 2:
    basestring = str
        
# Color Support
###############

class Term(object):
    """Gives easy access to ANSI color codes. Attempts to fall back to no color
    for certain TERM values. (Mostly stolen from IPython.)
    
    Now extended to include a couple miscellaenous text and console
    functions; it should probably be refactored and _d and _c made out
    of the same object."""

    COLOR_TEMPLATES = {
        "Black"       : "0;30",
        "Red"         : "0;31",
        "Green"       : "0;32",
        "Brown"       : "0;33",
        "Blue"        : "0;34",
        "Purple"      : "0;35",
        "Cyan"        : "0;36",
        "LightGray"   : "0;37",
        "DarkGray"    : "1;30",
        "LightRed"    : "1;31",
        "LightGreen"  : "1;32",
        "Yellow"      : "1;33",
        "LightBlue"   : "1;34",
        "LightPurple" : "1;35",
        "LightCyan"   : "1;36",
        "White"       : "1;37",
        "Bold"        : "1;1",
        "Normal"      : "0",
    }

    NoColor = ''
    Prompt  = '\001\033[%sm\002' # for use as sys.ps1; the '\001', '\002'
                                # indicate characters that don't count
    Simple = '\033[%sm'

    def __init__(self):
        templates = self.COLOR_TEMPLATES
        if 'BYellow' not in templates:
            for k,v in list(templates.items()):
                    templates['B' + k] = (templates[k] + ';' +
                                            templates['Bold'])
        
        self.default = self.Simple
        
    @property
    def cancolor(self):
        return os.environ.get('TERM') in ('xterm', 'xterm-color',
                'xterm-256color', 'linux', 'screen', 'screen-256color',
                'screen-bce')
    
    def getcol(self, colname, base = None):
        if base is None:
            base = self.default
        if base == self.NoColor:
            return ''
        else:
            return base % self.COLOR_TEMPLATES[colname]
    
    def splitter(self, txt, regexobj):
        """Splits txt based on a regexp, then yields (text, sep) pairs.
        
        Last pair is (finaltext, '')."""
        splits = iter(regexobj.split(txt))
        for word in splits:
            sep = ''
            try:
                sep = next(splits)
            except StopIteration:
                pass
            yield (word, sep)
        return
    
    @property
    def size(self):
        """Taken from stackoverflow"""
        h, w, hp, wp = struct.unpack('HHHH',
            fcntl.ioctl(0, termios.TIOCGWINSZ,
            struct.pack('HHHH', 0, 0, 0, 0)))
        return w, h
    
    @property
    def width(self):
        """Taken from stackoverflow"""
        h, w, hp, wp = struct.unpack('HHHH',
            fcntl.ioctl(0, termios.TIOCGWINSZ,
            struct.pack('HHHH', 0, 0, 0, 0)))
        return w
    
    def wrap(self, txt, width=None):
        import re
        if not width or width < 1:
            width = self.width
        newtxt=[]
        nextline=""
        curlength=0
        cursep=''
        curcol = ''
        colorwords = [re.escape(self.getcol(v))
                            for v in self.COLOR_TEMPLATES]
        colorwords = [v for v in colorwords if v]
        #print(repr('([' + ",".join(colorwords) + '])'))
        colre = re.compile('(' + "|".join(colorwords) + '+)')
        spacere = re.compile(r'([ \t]+)')
        newlinere = re.compile(r'(\n)')
        for (line, lbreak) in self.splitter(txt, newlinere):
            linesplit = [(line, '')]
            if colorwords:
                linesplit = self.splitter(line, colre)
            for (colgroup, color) in linesplit:
                #print(repr(colgroup + '---' + color))
                for (word, sep) in self.splitter(colgroup, spacere):
                    if curlength + len(cursep) + len(word) < width:
                        nextline += cursep + word
                        curlength += len(cursep) + len(word)
                        #print("; ".join((word, nextline, str(curlength))))
                    else:
                        newtxt.append(nextline)
                        nextline = word
                        curlength = len(word)
                    cursep = sep
                nextline += color
            newtxt.append(nextline)
            nextline = ''
            curlength = 0
        return '\n'.join(newtxt)
    
    def colorize(self, slist, base = None):
        """Takes a list of strings (displayed normally) or (col, string)
        pairs, and turns colors into terminal codes and displays."""
        lastcode = None
        finallist = []
        
        for s in slist:
            if isinstance(s, basestring):
                col = 'Normal'
            else:
                col, s = s
            code = self.getcol(col, base)
            if lastcode != code:
                finallist.append(code)
                lastcode = code
            finallist.append(s)
        finallist.append(self.getcol('Normal', base))
        
        return "".join(finallist)

def getterm(usecolor = True):
    term = Term()
    if not usecolor:
        term.default = term.NoColor
    return term

# see http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/438813/

import time, traceback, types
from code import InteractiveConsole
import imp
if pygmentsexists:
    if sys.version_info[0] > 2:
        from pygments.lexers import Python3Lexer as PythonLexer
    else:
        from pygments.lexers import PythonLexer
    from pygments.formatters import TerminalFormatter, Terminal256Formatter
    
    
#EDITOR = os.environ.get('EDITOR', 'geany')
#EDIT_CMD = '\e'

class KeywordConsole(InteractiveConsole):
    """A console with color and special keywords.
    
        This is the meat of jpython.
        See _banner for keywords.
        Lines are taken in by raw_input, preprocessed by various rules
        (affecting keywords, etc.), and then processed by the internals
        of InteractiveConsole. Most subfunctions are based on these
        keywords, and called from raw_input
        _KeywordConsole also has its own traceback function with colors;
        see showtraceback."""
    def __init__(self, term, savefile, aliases = None,
                usecolorprompts = True,
                timeout = 30*24*60*60,
                *args, **kwargs):
        if ['.'] not in sys.path and os.path.realpath('.') not in sys.path:
            sys.path.append('.')
        self.term = term
        self.savefile = savefile
        self.last_buffer = "" # This holds the last executed statement
        self._ = None
        self.shelf = None
        self.tdict = None
        self.lastmod = None
        self.lastmodlocalize = False
        self.aliases = aliases if aliases is not None else dict()
        if pygmentsexists:
            self.lexer = PythonLexer()
            self.formatter = Terminal256Formatter(style='native')
        self.timeout = timeout
        atexit.register(self.cleanup)
        self.initprompts(usecolorprompts)
        InteractiveConsole.__init__(self, *args, **kwargs)
        self.locals['_console'] = self
        self._modules = dict()
        for f in sys.argv[1:]:
            self.importfile(f, True)
        
    def initreadline(self):
        """Loads readline, starts a standard rlcompleter, and sets the
        namespace."""
        import rlcompleter
        self.completer = rlcompleter.Completer()
        rlcompleter.readline.parse_and_bind("tab: complete")
        rlcompleter.readline.set_completer(self.completer.complete)
        self.completer.use_main_ns = False
        self.completer.namespace = self.locals
        
    def inithist(self, histfile,readline=None):
        if readline is None:
            import readline

        # Read the existing history if there is one
        if os.path.exists(histfile):
            readline.read_history_file(histfile)
            
        # Set maximum number of items that will be written to the history file
        readline.set_history_length(300)

        def savehist():
            readline.write_history_file(histfile)

        atexit.register(savehist)

    
    def initprompts(self, usecolor = True):
        self._linenum = 1
        self._lastlinenum = 0
        term = self.term
        
        base = term.Prompt if term.default == term.Simple else term.NoColor
        # fancycompleter can't handle colorized prompts
        if 'fancycompleter' in sys.modules and base == term.Prompt:
            base = term.Simple
        if not usecolor:
            base = term.NoColor

        sys.ps1 = self.term.colorize([
            ('BLightGreen', '%d'), ('Green', '> ')], base)
        sys.ps2 = self.term.colorize([('Red','... ')], base)
        self.outps = self.term.colorize([
            ('BLightCyan', '%d'), ('Cyan', ': ')])
        sys.displayhook = self.displayhook
        
    
    def displayhook(self, value):
        "prints values with colored line numbers"
        if value is not None:
            outprompt = self.outps % (self._lastlinenum)
            valuestr = (pprint.pformat(value)) # _c.wrap
            sys.stderr.write(outprompt + valuestr + '\n')
    
    def runsource(self, source, *args, **kwargs):
        "Takes source code, attempts to parse, prints exceptions"
        self.last_buffer = source
        return InteractiveConsole.runsource(self, source, *args, **kwargs)
    
    def runcode(self, code):
        "Runs code and saves output"
        obj = InteractiveConsole.runcode(self, code)
        try:
            if None != obj:
                self._ = _
            return obj
        except AttributeError:
            self.showtraceback()
    
    def importfile(self, fname, localize=False, printout=True):
        """Import a file into self.locals.

        localize = False -> import file
        localize = True  -> import * from file"""
        
        #remove extension, if its there
        if fname[-3:] == '.py':
            fname = fname[:-3]
        
        def putindict(m, mname):
            self.lastmod = m
            self.lastmodlocalize = localize
            if fname not in self._modules or not self._modules[fname]:
                self._modules[fname] = localize
            if localize:
                self.locals.update(m.__dict__)
            else:
                #print(m, mname)
                self.locals[mname] = m
        
        def writemod(mname, reloaded=False):
            if not printout: return
            introword = 'Reloading ' if reloaded else 'Importing '
            if localize: introword += "all from "
            self.write(self.term.colorize([introword, ('BPurple', mname),'\n']))
        try:
            mod = sys.modules[fname]
            imp.reload(mod)
            putindict(mod, fname)
            writemod(fname, True)
            return
        except KeyError:
            pass
        
        try:
            mname = os.path.basename(fname)
            (file,path,descr) = imp.find_module(fname)
        except Exception:
            self.showtraceback()
            return
        try:
            #self.write("Using jpython import...\n")
            writemod(mname)
            m=imp.load_module(mname,file,path,descr)
            #print(m)
            putindict(m, mname)
        except Exception:
            #print(2)
            self.showtraceback()
    
    def colorize(self, name, obj=None):
        """Colorize 'name' as if it is obj, or find obj in locals if
        not given."""
        if not obj:
            obj = self.locals[name]
        if isinstance(obj, types.ModuleType):
            return self.term.colorize([('BPurple', name)])
        
        #otherwise _objects are white, normal are white
        elif name[:1] != '_':
            return self.term.colorize([('BLightRed', name)])
        else:
            return self.term.colorize([('BYellow', name)])
    
    def write(self, val):
        "What happens when you type 'print'"
        InteractiveConsole.write(self, val)
    
    def showtraceback(self):
        "Call from within an 'except:' clause to print the exception"
        global errtype, err, trace
        (errtype, err, trace) = sys.exc_info()
        colorize = self.term.colorize
        
        namestr = colorize([('BLightRed', errtype.__name__)])
        
        width = self.term.width
        sys.stderr.write(self.term.colorize([
            ('BLightRed', '-'*min(80, width)), '\n']))
        sys.stderr.write(namestr + ': ' + str(err) + '\n')
        for (fname, lineno, funcname, txt) in \
                            traceback.extract_tb(trace)[1:]:
            tstr = colorize(['  line ', ('BLightRed', str(lineno)),
            ' in ', ('BLightBlue',funcname), ', File \"',
             ('BPurple', fname), '\"\n'])
            if (lineno == 1 and funcname == '<module>' and 
                                fname == '<console>'):
                tstr += colorize(["    User input: ",
                ('Bold', self.last_buffer), '\n'])
            elif txt:
                tstr += colorize(['    ', ('Bold', txt), '\n'])
            sys.stderr.write((tstr)) # _c.wrap
            
    def showsyntaxerror(self, fname = ''):
        "Defines how syntax errors should be printed"
        colorize = self.term.colorize
        namestr = colorize([('BLightRed', "SyntaxError")])
        global errtype, err, trace
        (errtype, err, trace) = sys.exc_info()
        if fname == '<console>':
            namestr = colorize([('BLightRed', "SyntaxError"), ": ",
             str(err), '\n'])
            sys.stderr.write((namestr)) # _c.wrap
        else:
            self.showtraceback()
    
    def syntaxcolor(self, txt):
        if not self.term.cancolor or not pygmentsexists:
            return txt
        else:
            return pygments.highlight(txt, self.lexer, self.formatter)
    
    def getlocal(self, name):
        names = name.split('.')
        name = names[0]
        if name not in self.locals:
            self.write(self.term.colorize(['Object ', ('BLightRed', name),
                        ' not found.\n']))
            return
        obj = self.locals[name]
        for nextname in names[1:]:
            name = name + '.' + nextname
            try:
                obj = getattr(obj, nextname)
            except AttributeError:
                self.write(self.term.colorize(['Object ', ('BLightRed', name),
                        ' not found.\n']))
                return
        return obj
    
    def showsource(self, name):
        obj = self.getlocal(name)
        if obj is None:
            return
        try:
            txt = inspect.getsource(obj)
        except TypeError:
            txt = "Source for " + str(obj) + " could not be found."
        if self.term.default is not self.term.NoColor and self.term.cancolor:
            txt = self.syntaxcolor(txt)
        pydoc.pager(txt)
    
    def getshelf(self):
        "Gets the current shelf, opening the file if necessary"
        if not self.shelf == None:
            return self.shelf
        else:
            import shelve
            self.shelf = shelve.open(self.savefile)
            self.tdict = shelve.open(self.savefile + 'times')
            return self.shelf
    
    def saveobj(self, strng, prnt = True):
        """Save an object to the shelf.
        
        It would be cool if someday this handled modules by saving them
        as specials, and then when 'loaded' the module would be 
        imported."""
        if not strng:
            if prnt:
                self.write('Save requires string.\n')
            return
        if strng not in self.locals:
            if prnt:
                self.write(strng + ' does not exist.\n')
            return
        obj = self.locals[strng]
        if obj == None:
            del self.getshelf()[strng]
            del self.tdict[strng]
            if prnt:
                self.write(strng + ' removed.\n')
        else:
            self.getshelf()[strng] = obj
            self.tdict[strng] = time.time()
            if prnt:
                self.write(strng + ' saved.\n')
    
    def getobj(self, strng, prnt = True):
        "Reload an object from the shelf into self.locals"
        if strng in self.getshelf():
            obj = self.getshelf()[strng]
            self.locals[strng] = obj
            self.tdict[strng] = time.time()
            if prnt:
                self.write(strng + ', ' + str(type(obj)) + '\n')
        elif prnt:
                self.write(strng + ' not in save file.\n')
    
    def reget(self):
        self.getobj('_modules', False)
        moddict = self.locals.get('_modules', dict())
        for (fname, localize) in moddict.items():
            self.importfile(fname, localize)
        self.getobj('_lastlocals',False)
        self.locals.update(self.locals.get('_lastlocals', dict()))
        objstring = ', '.join(sorted(self.locals['_lastlocals'].keys()))
        print("Loading " + objstring)
    
    def listobj(self, hidden):
        names = []
        for (k,v) in sorted(self.locals.items()):
            if hidden or k[:1] != '_':
                names.append(self.colorize(k,v))
        s = (", ".join(names) + '\n')
        s = self.term.wrap(s)
        self.write(s)
    
    def cleanup(self):
        """Remove everything older than 'self.timeout' from the shelf, and
        save everything to lastlocals"""
        from pickle import PicklingError
        import time as _time #override anything else called time
        shelf = self.getshelf()
        for k in shelf:
            if k == '_times':
                continue
            elif k not in self.tdict:
                del self.shelf[k]
            elif self.tdict[k] < _time.time() - self.timeout:
                del self.shelf[k]
                del self.tdict[k]
        self.locals['_'] = self._
        lastlocals = dict()
        for name,obj in self.locals.items():
            if (name != '_' and name[:1] == '_') or not name:
                continue
            
            #print(name)
            try:
                lastlocals[name] = obj
                shelf['_lastlocals'] = lastlocals
                #print name
            except TypeError:
                del lastlocals[name]
            except PicklingError:
                del lastlocals[name]
        
        shelf['_modules'] = self._modules
        #print(list(self._modules.items()))
        
        self.tdict['_lastlocals'] = _time.time()
        shelf.sync()
        self.tdict.sync()
        self.clean = True
        #~ self.write('Cleaned up save file.\n')
    
    def syscall(self, s):
        prog, sep, tail = s.partition(' ')
        prog = self.aliases.get(prog, prog)
        return "os.system('''" + prog + sep + tail + "''')"
    
    def openeditor(self, name):
        obj = self.getlocal(name)
        editor = os.environ.get('EDITOR', 'vim')
        pass
    
    def raw_input(self, prompt):
        "Process the raw input from the editor, including keywords"
        lineprinted = False
        if '%d' in prompt:
            prompt = prompt % self._linenum
            lineprinted = True
        
        line = InteractiveConsole.raw_input(self, prompt)
        self._lastlinenum  = self._linenum
        
        if not line:
            return line
        try:
            if line.strip() == '??':
                os.system('$BROWSER \"http://docs.python.org/%s/\" &'
                                % sys.version[:3])
                line = ""
            elif line[:3] == 'cd ':
                p = os.path.expanduser(line[3:].strip())
                os.chdir(p)
                self.write(str(os.getcwd()) + '\n')
                line = ""
            elif line[:4] == 'get ':
                oname = line[4:]
                line = ''
                self.getobj(oname)
            elif line.strip() == 'reget':
                self.reget()
                line=''
            elif line[:3] == 'sv ':
                oname, line = line[3:], ''
                self.saveobj(oname)
            elif line[:2] == '??':
                self.showsource(line[2:].strip())
                line=''
            elif line[-2:] == '??':
                self.showsource(line[:-2].strip())
                line=''
            elif line[0] == '?':
                line = 'help(' + line[1:] + ')'
            elif line[-1] == '?':
                line = 'help(' + line[:-1] + ')'
            elif line[0] == ';':
                line = self.syscall(line[1:])
            elif line[:2] == 'i ':
                self.importfile(line[2:])
                line = ''
            elif line[:3] == 'ii ':
                self.importfile(line[3:],True)
                line = ''
            elif line == 'rel':
                if self.lastmod:
                    self.importfile(self.lastmod.__name__, self.lastmodlocalize)
                line = ''
            elif line.strip() == '.':
                self.listobj(False)
                line=''
            elif line.strip() == '..':
                self.listobj(True)
                line=''
            if lineprinted:
                    #print('\"\"\"%s\"\"\"' % line)
                    self._linenum += 1
        except Exception:
            self.showtraceback()
        return line

def getbanner(term):
    version = sys.version.splitlines()[0]
    verstring = term.colorize([('BYellow', 'Fancy Python ' + version)])
    banner = "_               -> Variable that represents last output\n"
    banner += "?**EXPR^^ or **EXPR^^?  -> help(**EXPR^^)\n"
    banner += "??              -> online help\n"
    banner += "??**OBJ^^ or **OBJ^^??-> show source for **OBJ^^\n"
    banner += ";**EXPR^^           -> shell call for **EXPR^^\n"
    banner += "i **NAME^^          -> import module **NAME^^\n"
    banner += "ii **NAME^^         -> import * from module **NAME^^\n"
    banner += "rel             -> reload last module\n"
    banner += "sv **NAME^^         -> save **NAME^^ to save file\n"
    banner += "                   del **NAME^^ if **NAME^^ is None\n"
    banner += "get **NAME^^        -> load **NAME^^ from save file\n"
    banner += "reget           -> load all variables from last session\n"
    banner += ". or ..         -> list all available objects\n"
    banner = banner.replace('**', term.getcol('Bold')).replace('^^',
                                    term.getcol('Normal'))
    
    return verstring + "\n" + banner


def impconfig():
    pth = '%s/.jpython/'  % os.environ["HOME"]
    try:
        mod, fp, desc = imp.find_module('config', [pth])
    except ImportError:
        return
    m = imp.load_module('jpyconfig', mod, fp, desc)
    return m

if __name__ == "__main__":
    # default config
    usereadline = True
    usecolor = True
    usecolorprompt = True
    savefile = '%s/.jpython/saves'  % os.environ["HOME"]
    aliases = {'ls':'ls --color=auto'}
    namespace = {}
    importall = []
    importlist = []
    histfile="%s/.pyhistory" % os.environ["HOME"]
    
    # overwrite with real config
    jpyconfig = impconfig()
    if jpyconfig:
        from jpyconfig import *
    
    term = getterm(usecolor)
    if 'banner' not in locals() and not sys.argv[1:]:
        banner = getbanner(term)
    elif not sys.argv[1:]:
        banner = ""
    
    # add a '3' for python3, so the shelf is not the same for python,
    # python3
    if sys.version_info[0] > 2:
        savefile += str(sys.version_info[0])
    if not os.path.exists(os.path.dirname(savefile)):
        os.makedirs(os.path.dirname(savefile))


    console = KeywordConsole(term= term, locals = namespace,
                aliases = aliases,
                savefile = savefile, usecolorprompts = usecolorprompt)
    namespace = console.locals
    namespace['_console'] = console

    
    if usereadline:
        if 'completer' not in locals():
            console.initreadline()
            console.inithist(histfile)
        else:
            console.inithist(histfile, completer.config.readline)
    
    if 'completer' in locals():
        namespace['_completer'] = completer
        completer.namespace = namespace
        completer.use_main_ns = False
    
    for mod in importall:
        console.importfile(mod, True, False)
    for mod in importlist:
        console.importfile(mod, False, False)
    
    console.interact(banner = banner)
    
    # Exit the Python shell on exiting the InteractiveConsole
    sys.exit()
